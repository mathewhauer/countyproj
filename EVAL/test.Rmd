---
title: "Evaluation of Population Projection Errors"
author: "Mathew E. Hauer"
date: "February 27, 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(data.table)
library(knitr)
library(scales)

setwd("C:/Users/Matt/Documents/Matt - Work Stuff/r code/myrepo/countyproj/EVAL/STATES/")

# SET THE GROUPING VARIABLES HERE
GROUPING <- c("STATE", "COUNTY", "YEAR")

test_year = 2000
launch_year = test_year
SIZE<-18
# NUMBER OF PROJECTION STEPS
STEPS<-3
FORLEN<-(STEPS*5)
BASEANDSTEPS<-STEPS+1
years <- 0
years$YEAR <- seq(launch_year+5,launch_year+(STEPS*5), 5)
years$YEAR <- seq(launch_year+1,launch_year+STEPS,1)


K05_pop <- read_csv("C:/Users/Matt/Documents/Matt - Work Stuff/r code/myrepo/countyproj/DATA/cendatbase.csv") %>%
  mutate(RACE = case_when(
    RACE == "BLACK, NH" ~ "BLACK",
    RACE == "OTHER" ~ "OTHER",
    RACE == "WHITE, NH" ~ "WHITE",
    RACE == "HISPANIC" ~ "WHITE",
    RACE == "OTHER, NH" ~ "OTHER"),
    AGE = AGEGRP) %>%
  group_by(.dots = GROUPING) %>%
  dplyr::summarise(POPULATION = sum(population)) 
K05_pop$GEOID <- paste0(K05_pop$STATE, K05_pop$COUNTY)
# K05_pop$COUNTYRACE <- paste0(K05_pop$GEOID, "_", K05_pop$RACE)
K05_launch <- K05_pop[which(K05_pop$YEAR == launch_year),]

fipslist <- read_csv(file="https://www2.census.gov/geo/docs/reference/codes/files/national_county.txt", col_names = FALSE) %>%
  mutate(GEOID = paste0(X2, X3)) %>%
  dplyr::rename(state = X1,
         STATEID = X2,
         CNTYID = X3,
         NAME = X4) %>%
  filter(!STATEID %in% c("60", "66", "69", "72", "74", "78"))

# Converting the fipslist into a unique list of 2-digit state ID's #
stateid = unlist(list(unique(fipslist$STATEID)))
# Converting the fipslist into a unique list of 5-digit county ID's #
GEOID = unlist(list(unique(fipslist$GEOID)))

statenames <- group_by(fipslist, STATEID, state) %>%
  dplyr::summarise()

files <- list.files(path = "C:/Users/Matt/Documents/Matt - Work Stuff/r code/myrepo/countyproj/EVAL/STATES",pattern = ".csv")
temp <- lapply(files, fread, sep=" ")
z <- rbindlist( temp ) %>%
  dplyr::rename(STATE = V2,
         COUNTY = V3,
         YEAR = V4,
         AGE = V5,
         RACE = V6,
         SEX = V7,
         POPULATION = V8,
         COUNTYRACE = V9,
         Var1 = V10,
         TYPE = V11,
         A = V12,
         B =V13,
         C =V14) %>%
  mutate(GEOID = paste0(STATE, COUNTY),
         A = if_else(A<0, 0, A),
         B = if_else(B<0, 0, B),
         C = if_else(C<0,0, C))


basesum <-  K05_launch[which( K05_launch$YEAR == launch_year),] %>%
  select(STATE, COUNTY, GEOID, POPULATION)

addsum <- z[which(z$TYPE=="ADD" & z$YEAR == (launch_year+FORLEN)),] %>%
  group_by(STATE, COUNTY, GEOID, TYPE) %>%
  dplyr::summarise(A = sum(A))

addmult <- left_join(addsum, basesum) %>%
  mutate(COMBINED = if_else(A> POPULATION, "ADD" ,"Mult")) %>%
  select(STATE, COUNTY, GEOID, COMBINED)



combined<- left_join(z, addmult) %>%
  filter(TYPE == COMBINED) %>%
  mutate(TYPE = "ADDMULT") %>%
  select(-COMBINED)

z<- rbind(z, combined)

```

# Overview

The cohort-component method is the most accepted methodology to produce population projections. The method makes use of all three population component processes (fertility, mortality, and migration) and applies them across varying population cohorts to arrive at a future population. Equation \ref{eq:cohortcomponent} outlines the basic structure of a cohort-component model.

\begin{equation}\label{eq:cohortcomponent}
P_{t+1} = P_t + B_t - D_t + M_{t,in} - M_{t,out}
\end{equation}

Where $P_t$ is the population at time $t$, $B_t$ is the births at time $t$, $D_t$ is the deaths at time $t$, and $M_{t, in/out}$ refers to in- or out-migration at time $t$.

Cohort-component requires data on each component process disaggregated by age, sex, and race. Certain elements of these data can be difficult to obtain for national coverage. Birth and death data are typically obtained through the National Center of Health Statistics (NCHS) vital events registration databases. These data, however, are only available for counties with populations greater than 100k and are suppressed in populations with fewer than 1k (I think) members rendering a universal county-level population projection difficult, if not impossible, to complete using publicly available datasets.

An alternative to cohort-component is the Hamilton-Perry method, which uses cohort-change ratios (CCRs) in place of components to project populations. The basic CCR equation is found in equation \ref{eq:ccr}.

\begin{eqnarray}\label{eq:ccr}
CCR_{t} & = & \frac{_nP_{x,t}}{_nP_{x-y,t-1}}\\
_nP_{x+t} & = & CCR_{t} \,\, \cdot \,\, _nP_{x-y,t}\nonumber
\end{eqnarray}

Where $_nP_{x,t}$ is the population aged $x$ to $x+n$ in time $t$ and $_nP_{x-y,t}$ is the population aged $x$ to $x+n-y$ in time $t$ where $y$ refers to the time difference between time periods. These CCRs are calculated for each age group $a$, for each sex group $s$, for each race group $r$, in each time period $t$, in county $c$. Thus to find the population of ten to fourteen year olds ($_5P_{10}$) in five years ($t+1$), we multiply the ratio of the population aged 10-14 in time $t$ ($_5P_{10,t}$) to the population aged 5-9 five-years prior in time $t-1$ ($_5P_{10-5,t-1}$) to the population aged 0-4 in time $t$ ($_5P_{10-5,t}$). ie, if we have 100 5-9 year olds five years ago and we now have 125 10-14 year olds and 90 5-9 year olds, we can expect the number of 10-14 year olds in 5 years to be (125/100 $\cdot$ 90 = 112.5).

Two age groups must have special consideration: the population aged 0-4 ($_5P_0$) and the population comprising the open-ended interval ($_{\infty}P_{85}$). The population aged 0-4 ($_5P_0$) must have special consideration since the preceding/proceeding age groups do not exist for these age groups. To calculate the CCR for the open-ended age group,
\begin{eqnarray}\label{eq:ccr_open}
_{\infty}CCR_{85,t} & = & \frac{_{\infty}P_{85,t}}{_{\infty}P_{85-y,t-1}}\\
_{\infty}P_{85+t} & = & _{\infty}CCR_{85,t} \,\, \cdot \,\, _{\infty}P_{85-y,t}\nonumber
\end{eqnarray}

Where $y$ is the time difference between time periods.

For the population aged 0-4, we use the ratio of the population aged 0-4 to the number of women of reproductive age. Here we define women of reproductive age as the ages $[15,50)$.

CCRs offer several advantages and disadvantages over the use of a cohort-component model. CCRs are considerably more parsimonious than cohort-component. Calculation of CCRs for use in population projections requires data as minimal as an age-sex distributions at two time periods -- data ubiquitous across multiple scales, countries, and time periods. However, this parsimony comes at a relatively steep price: CCRs can lead to impossibly explosive growth in long-range projections due to  the natural compounding of the ratios. Consider the growth currently occurring in McKenzie County, North Dakota (FIPS=38053) driving by the Shale oil boom. In 2010 McKenzie had a population of 6,360 that had ballooned to 12,792 by 2015, according to the Vintage 2016 population estimates from the US Census Bureau with a CCR for the 20-24 year old population of 2.46 (416 to 1,027). Implementing a 50-year population projection using that CCR would create a projected population that is approximately 8,000 times larger ($2.46^{10}$) -- clearly an improbable population given the small, rural nature of its population.

## Cohort Change Differences
The implementation of CCRs naturally implies a multiplicative model, typically utilizing leslie matrices. It is possible, however, to implement an **additive** model by using the *difference* in population rather than the *ratio* of population.

\begin{eqnarray}\label{eq:ccd}
CCD_{t} & = & _nP_{x,t} \,\, - \,\, _nP_{x-y,t-1}\\
_nP_{x+t} & = & CCD_{t} \,\, + \,\, _nP_{x-y,t}\nonumber
\end{eqnarray}

Where $_nP_{x,t}$ is the population aged $x$ to $x+n$ in time $t$ and $_nP_{x-y,t}$ is the population aged $x$ to $x+n-y$ in time $t$ where $y$ refers to the time difference between time periods. These CCDs are calculated for each age group $a$, for each sex group $s$, for each race group $r$, in each time period $t$, in county $c$. Thus to find the population of ten to fourteen year olds ($_5P_{10}$) in five years ($t+1$), we add the differene of the population aged 10-14 in time $t$ ($_5P_{10,t}$) to the population aged 5-9 five-years prior in time $t-1$ ($_5P_{10-5,t-1}$) to the population aged 0-4 in time $t$ ($_5P_{10-5,t}$). ie, if we have 100 5-9 year olds five years ago and we now have 125 10-14 year olds and 90 5-9 year olds, we can expect the number of 10-14 year olds in 5 years to be (125-100 $+$ 90 = 115).


## Projecting CCRs and CCDs

It is unlikely that CCRs will remain unchanged over the projection horizon. To account for possible changes in CCRs, I employed the use of an unobserved components model (UCM) for forecasting equally spaced univariate time series data (Harvey 1990). UCMs decompose a time series into components such as trends, seasons, cycles, and regression effects and are designed to capture the features of the series that explain and predict its behavior. UCMs are similar to dynamic models in Bayesian time series forecasting (Harrison and West 1999). All projections were undertaken in R using the RUCM package. 

The basic structural model (BSM) is the sum of its stochastic components. Here I use a trend component $\mu_t$  and a random error component $\varepsilon_t$ and it can be described as:

\begin{equation}
y_t = \mu_t + \varepsilon_t
\end{equation}
  
Each of the model components are modeled separately with the random error $\varepsilon_t$  modeled as a sequence of independent, identically distributed zero-mean Gaussian random variables. The trend component is modeled using the following equations:
 
\begin{align*}
\mu_t =   \mu_{t-1} + \beta_{t-1} +\eta_t\\
\beta_t = \beta_{t-1} + \xi_t\\
\eta_t \sim N(0,\sigma^2_\eta) \\
\xi_t \sim N(0,\sigma^2_\xi)
\end{align*} 
  
These equations specify a trend where the level $\mu_t$  and the slope $\beta_t$  vary over time, governed by the variance of the disturbance terms $\eta_t$ and $\xi_t$ in their equations. Here all individual CCRs/CCDs ($CCR_{iasr}$) over the series were modelled (n=339,444) in individual UCM models.

Rather than use the prediction intervals output from the UCMs, I set the upper and lower bounds as the projected UCM plus or minus the 80th percentile based on the standard deviation of the original time series. 

We forecast these UCMs for each CWR within a constrained forecast interval. CWRs are constrained to lie between ($a,b$). We limited CWRs such that each age/race/county combination would be constrained within the maximum/minimum of the time series such that $a=0$ for all projections. and $b=max(CWR_{arc})$. We then transform the data using a scaled logit transformation to map ($a,b$) to the whole real line
\begin{equation*}
y = log\big(\frac{x-a}{b-x}\big)
\end{equation*}

Where $x$ is the original data and $y$ is the transformed data. The prediction intervals from these transformations have the same coverage probability as on the transformed scale, because quantiles are preserved under monotonically increasing transformations.

The projected CCRs and CCDs are then input into Leslie matrices to create projected populations:
\[
\begin{bmatrix}
n_0 \\
n_1 \\
\vdots \\
n_{18}
\end{bmatrix}_{t+1}
=
\begin{bmatrix}
    0       & 0       	& 0       	& \dots 		& 0 & 0 \\
    CCR_{0} & 0       	& 0       	& \dots 		& 0 & 0 \\
    0       & CCR_{1} 	& 0       	& \dots 		& 0 & 0 \\
    0       & 0       	& CCR_{2} 	& \dots  		& 0 & 0 \\
   \vdots        & \vdots  		& \vdots 		& \ddots 	& 0 & 0 \\
    0 & 0 & 0 & \dots & CCR_{16} & CCR_{17}
\end{bmatrix}
\,\, \cdot \,\,
\begin{bmatrix}
n_0 \\
n_1 \\
\vdots \\
n_{17}
\end{bmatrix}_{t}
\]

\[
\mathbf{T}
=
\begin{bmatrix}
    0       & 0       	& 0       	& \dots 		& 0 & 0 \\
    CCD_{0} & 0       	& 0       	& \dots 		& 0 & 0 \\
    0       & CCD_{1} 	& 0       	& \dots 		& 0 & 0 \\
    0       & 0       	& CCD_{2} 	& \dots  		& 0 & 0 \\
   \vdots        & \vdots  		& \vdots 		& \ddots 	& 0 & 0 \\
    0 & 0 & 0 & \dots & CCD_{16} & CCD_{17}
\end{bmatrix}
\,\, + \,\,
\begin{bmatrix}
    0       & 0       	& 0       	& \dots 		& 0 & 0 \\
    n_{0} & 0       	& 0       	& \dots 		& 0 & 0 \\
    0       & n_{1} 	& 0       	& \dots 		& 0 & 0 \\
    0       & 0       	& n_{2} 	& \dots  		& 0 & 0 \\
   \vdots        & \vdots  		& \vdots 		& \ddots 	& 0 & 0 \\
    0 & 0 & 0 & \dots & n_{16} & n_{17}
\end{bmatrix}
\]

\[
P_{t+1}
\equiv
\begin{bmatrix}
\sum \mathbf{T_{1i}} \\
\sum \mathbf{T_{2i}} \\
\vdots \\
\sum \mathbf{T_{17i}}
\end{bmatrix}
\]


The population aged 0-4 in time $t+1$ are projected by applying a 1.05 sex ratio at birth (SRB) to the women of childbearing age $[15,50)$ in time $t+1$.


## Extra considerations

These projections were carried out with 18 age groups (0,85,5), 2 sex groups, and 3 race groups (White, Black, Other).


All *resident* populations are projected in this modelling scheme such that the populations at launch year are equal to the total population minus the group quarters population. Group quarters populations at time $t$ are then added back into the resident population at time $t+1$.

Several county boundaries have also shifted since 1980:

* FIPS 12025 was changed to 12086.
* FIPS 15005 was absorbed by FIPS 15009. 
* FIPS 51780 was merged into 51083.
* FIPS 51560 was merged into 51005.
* FIPS 30113 was split  into 30031 and 30067. All three have been merged into 30031 -- the larger county.
* FIPS 08014 was created out of parts of 08013, 08123, 08001, and 08059. Over 90% of the created population came out of 08013 so it is remerged.
* FIPS 02105 was created from 02105, 02230, and 02232 were all created out of the same 02230. 02230 was changed in 1992 from 02231.
* FIPS 02130, 02195, 02198, 02201, 02275, and 02280 were carved out of 02130.
* FIPS 02270 was recoded to 02158.
* FIPS 46113 was recoded to 46102.

In the event a UCM contained NA or infinite values or produced covariance matrices with values larger than 10,000,000, the projections were set to 0. Upper and Lower bounds of failed UCMs were set to 0. Additionally, any infinite, NA, or NAN CCR, CCD, or CWR was set to 0.

**States included in this analysis: **`r unique(fipslist$state[which(fipslist$STATEID %in% unique(z$STATE))])`

**Total number of counties: **`r length(unique(paste0(z$STATE, z$COUNTY)))`

# Overall Errors

Table 1 reports the overall errors for the sum of the population in each of the subsequent states and counties. Overall the purely ADDITIVE model outperformed the purely MULTIPLICATIVE model, suggesting CCDs could produce more accurate results compared to CCRs.

```{r TOTAL eval, echo=FALSE, results='asis'}
eval_ucm_statetotal <- z %>%
  #mutate(RACE = substr(countyrace, 7,25))
  group_by(TYPE, YEAR) %>%
  summarise(POPULATION = sum(POPULATION),
            A = sum(A),
            B = sum(B),
            C = sum(C),
            num = length(A)) %>%
  mutate(FLAG1 = abs(if_else(is.na((A/POPULATION)-1), 0,(A/POPULATION)-1)),
         FLAG2 = if_else(POPULATION>=B & POPULATION<=C,1,0),
         in90percentile = FLAG2/num,
         PRED= prettyNum(A, big.mark=",", scientific=FALSE),
         LOW = prettyNum(B, big.mark=",", scientific=FALSE),
         HIGH = prettyNum(C, big.mark=",", scientific=FALSE),
         MAPE = percent(FLAG1),
         POPULATION = prettyNum(POPULATION, big.mark=",", scientific=FALSE)) %>%
  select(-num, -FLAG2, -in90percentile, -A, -B, -C, -FLAG1)

kable(eval_ucm_statetotal, caption="Evaluation of TOTAL Errors. MAPE refers to MEDIAN Absolute Percent Error", digits = 4)
```


```{r STATE TOTAL eval, echo=FALSE, results='asis'}
eval_ucm_cntytotal <- z %>%
  group_by(STATE, COUNTY, YEAR, TYPE) %>%
  dplyr::summarise(POPULATION = sum(POPULATION),
                   A = sum(A),
                   B = sum(B),
                   C = sum(C),
                   num = length(A)) %>%
  mutate(FLAG1 = if_else(is.na((A/POPULATION)-1), 0,(A/POPULATION)-1),
         FLAG2 = if_else(POPULATION>=B & POPULATION<=C,1,0),
         in90percentile = FLAG2/num) %>%
  ungroup() %>%
  group_by(YEAR, STATE, TYPE) %>%
  dplyr::summarise(MAPE = quantile(abs(FLAG1), 0.5),
                   in80percentile = sum(FLAG2)/length(FLAG2),
                   COUNTYnum = length(FLAG2)) %>%
  mutate(MAPE= percent(MAPE),
         in80percentile = percent(in80percentile)) %>%
  dplyr::rename(STATEID = STATE)



eval_ucm_cntytotal <- left_join(eval_ucm_cntytotal, statenames) %>%
  ungroup()%>%
  select(-STATEID, -in80percentile) %>%
  group_by(state, TYPE, COUNTYnum) %>%
  spread(YEAR, MAPE) %>%
  arrange(state, TYPE)

kable(eval_ucm_cntytotal, caption="Evaluation of STATE Errors. MAPE refers to MEDIAN Absolute Percent Error", digits = 4)
```

The total error for any given county is also small and only marginally larger than the nationwide total.

```{r TOTAL COUNTY eval, echo=FALSE, results='asis'}
eval_ucm_cntytotal <- z %>%
  group_by(STATE, COUNTY, YEAR, TYPE) %>%
  dplyr::summarise(POPULATION = sum(POPULATION),
            A = sum(A),
            B = sum(B),
            C = sum(C),
            num = length(A)) %>%
  mutate(FLAG1 = if_else(is.na((A/POPULATION)-1), 0,(A/POPULATION)-1),
         FLAG2 = if_else(POPULATION>=B & POPULATION<=C,1,0),
         in90percentile = FLAG2/num) %>%
  ungroup() %>%
  group_by(YEAR, TYPE) %>%
  dplyr::summarise(MAPE = quantile(abs(FLAG1), 0.5),
            in80percentile = sum(FLAG2)/length(FLAG2),
            COUNTYnum = length(FLAG2)) %>%
  mutate(MAPE= percent(MAPE),
         in80percentile = percent(in80percentile))

temp_ageMAPE_add <- filter(eval_ucm_cntytotal, TYPE=="ADD") %>%
  select(YEAR, COUNTYnum, MAPE, TYPE) %>%
  spread(YEAR, MAPE) %>%
  mutate(VAR = "MAPE")
temp_ageMAPE_mult <- filter(eval_ucm_cntytotal, TYPE=="Mult") %>%
  select(YEAR, COUNTYnum, MAPE, TYPE) %>%
  spread(YEAR, MAPE) %>%
  mutate(VAR = "MAPE")
temp_agePER_add <- filter(eval_ucm_cntytotal, TYPE=="ADD") %>%
  select(YEAR, COUNTYnum, in80percentile, TYPE) %>%
  spread(YEAR, in80percentile) %>%
  mutate(VAR = "in 80th percentile")
temp_agePER_mult <- filter(eval_ucm_cntytotal, TYPE=="Mult") %>%
  select(YEAR, COUNTYnum, in80percentile, TYPE) %>%
  spread(YEAR, in80percentile) %>%
  mutate(VAR = "in 80th percentile")
temp_ageMAPE_addmult <- filter(eval_ucm_cntytotal, TYPE=="ADDMULT") %>%
  select(YEAR, COUNTYnum, MAPE, TYPE) %>%
  spread(YEAR, MAPE) %>%
  mutate(VAR = "MAPE")
temp_agePER_addmult <- filter(eval_ucm_cntytotal, TYPE=="ADDMULT") %>%
  select(YEAR, COUNTYnum, in80percentile, TYPE) %>%
  spread(YEAR, in80percentile) %>%
  mutate(VAR = "in 80th percentile")

eval_ucm_county_TOTAL <- rbind(temp_ageMAPE_add, temp_ageMAPE_mult, temp_ageMAPE_addmult, temp_agePER_add, temp_agePER_mult, temp_agePER_addmult) %>%
  select(COUNTYnum, TYPE, VAR, "2005","2010", "2015")
rm(temp_ageMAPE_add, temp_agePER_add, temp_ageMAPE_mult, temp_agePER_mult, temp_ageMAPE_addmult, temp_agePER_addmult)

kable(eval_ucm_county_TOTAL, caption="Evaluation of TOTAL Errors for counties. MAPE refers to MEDIAN Absolute Percent Error", digits = 4)
```

## Errors by Age

The errors for age groups are also relatively low with the average age group having an overall error of 13%.

```{r ages total, echo=FALSE, results='asis'}
eval_ucm_agetotal <- z %>%
  group_by(STATE, COUNTY, AGE, YEAR, TYPE) %>%
  summarise(POPULATION = sum(POPULATION),
            A = sum(A),
            B = sum(B),
            C = sum(C),
            num = length(A)) %>%
  mutate(FLAG1 = if_else(is.na((A/POPULATION)-1), 0,(A/POPULATION)-1),
         FLAG2 = if_else(POPULATION>=B & POPULATION<=C,1,0),
          in90percentile = FLAG2/num) %>%
  ungroup() %>%
  group_by(YEAR, TYPE) %>%
  summarise(MAPE = quantile(abs(FLAG1), 0.5),
            in80percentile = sum(FLAG2)/length(FLAG2),
            num = length(FLAG2)) %>%
  ungroup()
temp_ageMAPE_add <- filter(eval_ucm_agetotal, TYPE=="ADD") %>%
  select(YEAR, num, MAPE, TYPE) %>%
  spread(YEAR, MAPE) %>%
  mutate(VAR = "MAPE")
temp_agePER_add <- filter(eval_ucm_agetotal, TYPE=="ADD") %>%
  select(YEAR, num, in80percentile, TYPE) %>%
  spread(YEAR, in80percentile) %>%
  mutate(VAR = "in 80th percentile")
temp_ageMAPE_mult <- filter(eval_ucm_agetotal, TYPE=="Mult") %>%
  select(YEAR, num, MAPE, TYPE) %>%
  spread(YEAR, MAPE) %>%
  mutate(VAR = "MAPE")
temp_agePER_mult <- filter(eval_ucm_agetotal, TYPE=="Mult") %>%
  select(YEAR, num, in80percentile, TYPE) %>%
  spread(YEAR, in80percentile) %>%
  mutate(VAR = "in 80th percentile")

eval_ucm_age_TOTAL <- rbind(temp_ageMAPE_add, temp_ageMAPE_mult, temp_agePER_add, temp_agePER_mult) %>%
  select(num, TYPE, VAR, "2005","2010", "2015")
rm(temp_ageMAPE_add, temp_agePER_add, temp_ageMAPE_mult, temp_agePER_mult)

# kable(eval_ucm_age_TOTAL, caption="A table test", digits = 4)
# formatted_table <- as.data.frame(matrix(
#    sprintf("%.0f%%", eval_ucm_age_TOTAL*100),
#    nrow(eval_ucm_age_TOTAL),
#    dimnames = dimnames(eval_ucm_age_TOTAL)
# ))

kable(eval_ucm_age_TOTAL, caption="Evaluation of Age Group Errors. MAPE refers to MEDIAN Absolute Percent Error", digits = 4)
```

## Errors by Sex

```{r sex total, echo=FALSE, results='asis'}
eval_ucm_sextotal <- z %>%
  group_by(STATE, COUNTY, SEX, YEAR, TYPE) %>%
  summarise(POPULATION = sum(POPULATION),
            A = sum(A),
            B = sum(B),
            C = sum(C),
            num = length(A)) %>%
  mutate(FLAG1 = if_else(is.na((A/POPULATION)-1), 0,(A/POPULATION)-1),
         FLAG2 = if_else(POPULATION>=B & POPULATION<=C,1,0),
         in90percentile = FLAG2/num) %>%
  ungroup() %>%
  group_by(YEAR, SEX, TYPE) %>%
  summarise(MAPE = quantile(abs(FLAG1), 0.5),
            in80percentile = sum(FLAG2)/length(FLAG2),
            num = length(FLAG2)) %>%
  mutate(MAPE= percent(MAPE),
         in80percentile = percent(in80percentile)) %>%
  #arrange(RACE, TYPE, YEAR) %>%
  select(num, SEX, TYPE, YEAR, MAPE,in80percentile)

kable(eval_ucm_sextotal, caption="Evaluation of Sex Errors. MAPE refers to MEDIAN Absolute Percent Error", digits = 4)
```

## Errors by Race



```{r RACE total, echo=FALSE, results='asis'}
eval_ucm_racetotal <- z %>%
  group_by(STATE, COUNTY, RACE, YEAR, TYPE) %>%
  summarise(POPULATION = sum(POPULATION),
            A = sum(A),
            B = sum(B),
            C = sum(C),
            num = length(A)) %>%
  mutate(FLAG1 = if_else(is.na((A/POPULATION)-1), 0,(A/POPULATION)-1),
         FLAG2 = if_else(POPULATION>=B & POPULATION<=C,1,0),
         in90percentile = FLAG2/num) %>%
  ungroup() %>%
  group_by(YEAR, RACE, TYPE) %>%
  summarise(MAPE = quantile(abs(FLAG1), 0.5),
            in80percentile = sum(FLAG2)/length(FLAG2),
            num = length(FLAG2)) %>%
  mutate(MAPE= percent(MAPE),
         in80percentile = percent(in80percentile)) %>%
  arrange(RACE, TYPE, YEAR) %>%
  select(num, RACE, TYPE, YEAR, MAPE,in80percentile)



kable(eval_ucm_racetotal, caption="Evaluation of Race Errors. MAPE refers to MEDIAN Absolute Percent Error", digits = 4)
```

## Errors for all joint combinations

```{r asr total, echo=FALSE, results='asis'}
eval_ucm_asrtotal <- z %>%
  group_by(STATE, COUNTY, RACE, AGE, SEX, YEAR, TYPE) %>%
  summarise(POPULATION = sum(POPULATION),
            A = sum(A),
            B = sum(B),
            C = sum(C),
            num = length(A)) %>%
  mutate(FLAG1 = if_else(is.na((A/POPULATION)-1), 0,(A/POPULATION)-1),
         FLAG2 = if_else(POPULATION>=B & POPULATION<=C,1,0),
         in90percentile = FLAG2/num) %>%
  ungroup() %>%
  group_by(YEAR, TYPE) %>%
  summarise(MAPE = quantile(abs(FLAG1), 0.5),
            in80percentile = sum(FLAG2)/length(FLAG2),
            num = length(FLAG2)) %>%
  mutate(MAPE= percent(MAPE),
         in80percentile = percent(in80percentile)) %>%
  #arrange(RACE, TYPE, YEAR) %>%
  select(num, TYPE, YEAR, MAPE,in80percentile)



kable(eval_ucm_asrtotal, caption="Evaluation of Age/Sex/Race Errors. MAPE refers to MEDIAN Absolute Percent Error", digits = 4)
```

